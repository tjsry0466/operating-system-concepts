# 프로세스 관리

### 프로세스

프로세스란 실행중인 프로그램.
프로세스의 현재 활동의 상태는 프로그램 카운터 값과 프로세서 레지스터의 내용으로 나타낸다.

> 프로그램 카운터란?

프로그램 카운터(Program Counter, PC)는 CPU 내부의 중요한 레지스터 중 하나로, 현재 실행 중인 명령어의 주소를 저장하는 역할을 합니다. 프로그램 카운터는 명령어의 흐름을 제어하고 프로그램의 순차적인 실행을 가능하게 하는 핵심적인 컴포넌트입니다.

### 프로그램 카운터의 기능

1. **명령어 주소 저장**: 프로그램 카운터는 현재 실행 중인 명령어의 주소를 저장합니다. CPU가 명령어를 실행할 때마다 프로그램 카운터는 해당 명령어의 메모리 주소를 가리킵니다.
2. **명령어 순차 실행**: CPU가 명령어를 실행한 후, 프로그램 카운터는 자동으로 다음 명령어의 주소로 증가합니다. 일반적으로 명령어의 크기(예: 1바이트, 4바이트 등)에 따라 증가합니다. 이로 인해 프로그램은 순차적으로 명령어를 실행할 수 있습니다.
3. **분기와 점프 처리**: 조건부 또는 무조건부 분기 명령어가 실행되면, 프로그램 카운터는 다음 실행할 명령어의 주소를 해당 분기 주소로 설정합니다. 이는 프로그램 흐름의 제어를 가능하게 하며, 반복문, 조건문 등의 구현을 지원합니다.
4. **인터럽트 처리**: 인터럽트가 발생하면, 현재 명령어의 주소는 저장되고, 프로그램 카운터는 인터럽트 서비스 루틴(ISR)의 시작 주소로 설정됩니다. 인터럽트 처리가 완료되면, 프로그램 카운터는 원래의 실행 위치로 복원됩니다.

### 프로그램 카운터의 동작 과정

1. **명령어 가져오기(Fetch)**: 프로그램 카운터가 가리키는 메모리 주소에서 명령어를 가져옵니다.
2. **명령어 실행(Execute)**: 가져온 명령어를 디코드하고 실행합니다.
3. **프로그램 카운터 증가(Update PC)**: 다음 명령어의 주소로 프로그램 카운터를 증가시킵니다.

이 과정은 반복적으로 수행되어 프로그램이 순차적으로 실행됩니다.

### 예시

다음은 간단한 프로그램의 실행 예시입니다:

assembly

코드 복사

`0x0000: LOAD R1, 0x1000   ; R1에 메모리 주소 0x1000의 값을 로드 0x0004: ADD R1, R2        ; R1에 R2의 값을 더함 0x0008: STORE R1, 0x1004  ; R1의 값을 메모리 주소 0x1004에 저장 0x000C: JMP 0x0000        ; 0x0000 주소로 점프`

- **시작 시**: 프로그램 카운터(PC)는 0x0000을 가리킵니다.
- **LOAD 명령어 실행 후**: PC는 0x0004로 증가합니다.
- **ADD 명령어 실행 후**: PC는 0x0008로 증가합니다.
- **STORE 명령어 실행 후**: PC는 0x000C로 증가합니다.
- **JMP 명령어 실행 후**: PC는 0x0000으로 설정되어 프로그램의 처음으로 되돌아갑니다.

### 프로그램 카운터의 중요성

- **프로그램 흐름 제어**: 프로그램 카운터는 명령어의 순차적인 실행을 가능하게 하며, 조건부 분기, 반복문, 함수 호출 등의 제어 구조를 지원합니다.
- **디버깅**: 프로그램 카운터의 값은 디버깅 과정에서 현재 실행 중인 명령어를 확인하는 데 사용됩니다. 이를 통해 오류를 추적하고 수정할 수 있습니다.
- **효율적인 CPU 동작**: 프로그램 카운터는 명령어의 주소를 효율적으로 관리하여 CPU가 고속으로 명령어를 처리할 수 있도록 합니다.

프로그램 카운터는 CPU의 필수적인 레지스터로서, 프로그램의 올바른 실행과 흐름 제어를 담당합니다. 이를 통해 복잡한 프로그램의 실행이 가능해지고, 다양한 제어 구조를 구현할 수 있습니다.

---

프로세스의 메모리 배치는 일반적으로 여러 섹션으로 구분됩니다.

- 텍스트 섹션
  - 실행 코드
- 데이터 섹션
  - 전역 변수
- 힙 섹션
  - 프로그램 실행 중에 동적으로 할당되는 메모리
- 스택 섹션
  - 함수를 호출할 때 임시 데이터 저장장소(함수 매개변수, 복귀 주소 및 지역 변수)

설명

- 텍스트 및 데이터 섹션의 크기는 고정되기 때문에 프로그램 실행 시간 동안 크기가 변하지 않는다.
- 스택 및 힙 섹션은 프로그램 실행 중에 동적으로 줄어들거나 커질 수 있다.
- 함수가 호출될 때마다 함수 매개변수, 지역 변수 및 복귀 주소를 포함하는 `활성화 레코드`가 스택에 푸시 된다. 함수에서 제어가 되돌아오면 스택에서 활성화 레코드가 팝 된다.
- 마찬가지로 메모리가 동적으로 할당됨에 따라 힙이 커지고 메모리가 시스템에 반환되면 축소된다
- 스택 및 힙 센션이 서로의 방향으로 커지더라도 운영체제는 서로 겹치지 않도록 해야한다.

### 프로세스 상태

- 생성중(new): 프로세스가 생성중인 상태
- 실행중(running): 명령어들이 실행중인 상태
- 대기중(waiting): 프로세스가 어떤 이벤트가 일어나기를 기다리는 상태
- 준비(ready): 프로세스가 처리되기에 할당되기를 기다리는 상태
- 종료(terminated): 프로세스의 실행이 종료된 상태

### 프로세스 제어 블록

각 프로세스는 운영체제에서 프로세스 제어 블록(PCB)에 의해 표현된다.

PCB는 약간의 회계 데이터와 함께 프로세스를 시작시키거나 다시 시작시키는 데 필요한 모든 데이터를 위한 저장소의 역할을 한다.

PCB 구성요소

- 프로세스 상태
- 프로그램 카운터
  - 프로세스가 다음에 실행할 명령어의 주소를 가리킴
- CPU 레지스터
  - 누산기, 인덱스 레지스터, 스택 레지스터, 범용 레지스터들과 상태코드가 포함
  - 프로그램 카운터와 함께 이 상ㅌ태 정보는, 나중에 프로세스가 다시 스케줄 될 때 계속 올바르게 실행되도록 하기 위해서 인터럽트 발생 시 저장되어야 한다.
- CPU 스케쥴링 정보
  - 프로세스 우선순위, 스케줄 큐에 대한 포인트와 다른 스케줄 매개변수를 포함
- 메모리 관리 정보
  - 운영체제가 사용하는 메모리 시스템에 따라 base 레지스터와 limit 레지스터의 값, 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함
- 회계(accounting) 정보
  - CPU사용 시간과 경과된 실시간, 시간 제한, 계정 번호, 잡 또는 프로세스 번호 등을 포함한다.
- 입출력 상태 정보
  - 프로세스에 할당된 입출력 장치들과 열린 파일의 목록 등을 포함한다.

> CPU 레지스터란?

CPU 레지스터는 중앙처리장치(CPU) 내부에 있는 고속 메모리 장치로, 데이터와 명령어를 저장하고 처리하는 데 사용됩니다. 레지스터는 매우 빠르며 CPU의 연산 속도를 크게 향상시킵니다. 일반적으로 레지스터는 다음과 같은 종류로 구분됩니다:

일반 목적 레지스터 (General-Purpose Registers, GPRs): 주로 데이터나 주소를 임시로 저장하는 데 사용됩니다. x86 아키텍처에서는 EAX, EBX, ECX, EDX 등이 이에 해당합니다.

특수 목적 레지스터 (Special-Purpose Registers): 특정한 기능을 수행하는 레지스터입니다.

프로그램 카운터 (Program Counter, PC): 현재 실행 중인 명령어의 주소를 저장합니다.
스택 포인터 (Stack Pointer, SP): 스택의 최상단 주소를 가리킵니다.
프레임 포인터 (Frame Pointer, FP): 현재 함수 호출의 프레임을 가리킵니다.
플래그 레지스터 (Flags Register): 연산 결과의 상태(예: 제로, 오버플로우, 부호 등)를 저장합니다.
어드레스 레지스터 (Address Registers): 메모리 주소를 저장하는 데 사용됩니다. 예를 들어, x86 아키텍처에서는 ESI, EDI, EBP, ESP 등이 어드레스 레지스터로 사용될 수 있습니다.

데이터 레지스터 (Data Registers): 데이터 연산에 사용되는 레지스터입니다. 예를 들어, x86 아키텍처에서는 AX, BX, CX, DX 등이 이에 해당합니다.

레지스터는 매우 빠른 액세스 속도를 가지고 있으며, CPU가 직접 접근할 수 있는 가장 빠른 메모리입니다. 이러한 이유로 연산 중간 결과나 중요한 데이터를 저장하는 데 매우 유용합니다. 레지스터의 수와 종류는 CPU 아키텍처에 따라 다르며, 각 아키텍처는 고유한 레지스터 집합을 가지고 있습니다.

### 쓰레드

하나의 프로세스는 여러개의 쓰레드를 가지며 여러가지의 일을 동시에 처리할 수 있다.

### 프로세스 스케줄링

- 다중 프로그래밍의 목적은 CPU 이용을 최대화하기 위하여 핫앗 어떤 프로세스가 실행되도록 하는 데 있다.
- 시분할의 목적은 각 프로그램이 실행되는 동안 사용자가 상호 작용할 수 있도록 프로세스들 사이에서 CPU 코어를 빈번하게 교체하는 것이다.
- 이 목적을 달성하기 위해 프로세스 스케줄러는 코어에서 실행 가능한 여러 프로세스 중에서 하나의 프로세스를 선택한다.
- 각 CPU 코어는 한 번에 하나의 프로세스를 실행할 수 있다.
- 단일 CPU 코어가 있는 시스템의 경우 한 번에 2개 이상의 프로세스가 실행될 수 없지만 다중 코어 시스템은 한 번에 여러 프로세스를 실행할 수 있다. 코어보다 많은 프로세스가 있는 경우 초과 프로세스는 코어가 사용 가능해지고 다시 스케줄 될 떄까지 기다려야 한다. 현재 메모리에 있는 프로세스 수를 다중 프로그래밍 정도라고 한다.

스케줄링 큐

- 프로세스가 시스템에 들어가면 준비 큐에 들어가서 준비 상태가 되어 CPU에서 실행되기를 기다린다.
- 준비 큐 헤더에는 리스트의 첫 번째 PCB에 대한 포인터가 저장되고 각 PCB에는 준비 큐의 다음 PCB의를 가리키는 포인터 필드가 포함된다.
- 시스템에는 다른 큐도 존재한다. 프로세스에 CPU 코어가 할당되면 프로세스는 잠시 동안 실행되어 결국 종료되거나 인터럽트 되거나 I/O 요청의 완료와 같은 특정 이벤트가 발생할 떄까지 기다린다.
- 프로세스가 디스크와 같은 장치에 I/O 요청을 한다고 가정할때 장치는 프로세스보다 상당히 느리게 실행되므로 프로세스는 I/O가 사용 가능할 때까지 기다려야 한다. I/O 완료와 같은 특정 이벤트가 발생하기를 기다리는 프로세스는 대기 큐에 삽입된다.

CPU에서 요청을 처리하다가 입출력, 타임슬라이스 종료, 자식 프로세스 생성, 인터럽트 대기를 이유로 대기 큐로 돌아갈 수 있다.

### CPU 스케줄링

- 프로세스는 수명주기 동안 준비 큐와 다양한 대기 큐를 이주한다.
- CPU 스케줄러 의 역할은 준비 큐에 있는 프로세스 중에서 선택된 하나의 프로세스에 CPU 코어를 할당하는 것이다. CPU 스케줄러는 CPU를 할당하기 위한 새 프로세스를 자주 선택해야 한다.
- I/O 바운드 프로세스는 I/O 요청을 대기하기 전에 몇 밀리초 동안만 실행할 수 있다.
- CPU 바운드 프로세스에는 오랜 시간 동안 CPU 코어가 필요하지만 스케줄러는 프로세스에게 코어를 장기간 부여할 가능성이 없다. 대신 프로세스에서 CPU를 강제로 제거하고 실행될 다른 프로세스를 스케줄 하도록 설계될 가능성이 높다. 따라서 CPU 스케줄러는 일반적으로 훨씬 더 자주 실행되지만 적어도 100ms마다 한 번씩 실행된다.

일부 운영체제는 `스와핑`으로 알려진 중간 형태의 스케줄링을 가지고 있는데, 핵심 아이디어는 때로는 메모리에서(및 CPU에 대한 능동적 경쟁에서) 프로세스를 제거하여 프로그래밍의 정도를 감소시키는 것이 유리할 수 있다는 것이다. 나중에 프로세스를 메모리에 다시 적재될 수 있으며 중단된 위치에서 실행을 계속할 수 있다. 프로세스를 메모리에서 디스크로 "스왑아웃"하고 현재 상태를 저장하고, 이후 디스크에서 메모리로 "스왑인"하여 상태를 복원할 수 있기 때문에 이 기법을 스와핑이라고 한다. 스와핑은 일반적으로 메모리가 초과 사용되어 가용공산을 확보해야 할 때만 필요하다.

### 문맥 교환

- 인터럽트는 운영체제가 CPU 코어를 현재 작업에서 뺏어 커널 루틴을 실행할 수 있게 한다. 이러한 연산은 범용 시스템에서는 자주 발생한다.
  인터럽트가 발생하면 시스템은 인터럽트 처리가 끝난 후에 문맥을 복구할 수 있도록 현재 실행중인 프로세스의 현재 문맥을 저장할 필요가 있다. 이는 결국 프로세스를 중단했다가 재개하는 작업이다.
- 문맥은 프로세스의 PCB에 표현된다. 문맥은 CPU의 레지스터의 값, 프로세스 상태, 메모리 관리 정보 등을 포함한다.
- 일반적으로 커널 모드이건 사용자 모드이건 CPU의 현재 상태를 저장하는 작업을 수행(state save)하고 나중에 연산을 재개하기 위하여 상태 복구작업을 수행(state restore)한다.
- CPU 코어를 다른 프로세스로 교환하려면 이전의 프로세스의 상태를 보관하고 새로운 프로세스릐 보관된 상태를 복구하는 작업이 필요하다. 이 작업을 `문맥 교환`이라고 한다.
- 문맥 교환이 일어나면 커널은 과거 프로세스의 문맥을 PCB에 저장하고, 실행이 스케줄된 새로운 프로세스의 저장된 문맥을 복구한다. 문맥 교환이 진행될 동안 시스템이 아무런 유용한 일을 못 하기 때문에 문맥 교환 시간은 순수한 오버헤드이다. 교환 속도는 메모리의 속도, 반드시 복사되어야 하는 레지스터의 수, 특수 명령어(모든 레지스터를 하나의 명령어로 보관하고 적재하는 것 같은)의 존재에 좌우되므로, 기계마다 다르다. 전형적인 속도는 수 마이크로초까지 분포되어 있다.

문맥 교한 시간은 하드웨어의 지원에 크게 좌우된다. 예를 들어, 일부 처리기들은 여러 개의 레지스터 집합을 제공한다. 문맥 교환은 단순히 현행 레지스터 집합에 대한 포인터를 변경하는 것을 포함한다. 물론, 레지스터 집합들보다도 활성 프로세스들이 더 많다면, 시스템은 전처럼 레지스터 자료를 메로리로 또는 메모리에서 복사해야 한다. 또한 운영체제가 복잡할수록, 문맥 교환 시 해야 할 작업의 양이 더 많아진다.
