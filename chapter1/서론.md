# 1.2 컴퓨터 시스템의 구성

- 현대의 범용 컴퓨터 시스템은 하나 이상의 CPU와 구성 요소와 공유 메모리 사이의 액세스를 제공하는 공통 버스를 통해 연결된 여러 장치 컨트롤러로 구성된다.
- 각 장치 컨트롤러마다 장치 드라이버가 있다.

### 버스란?

버스(Bus)란 컴퓨터 시스템 내에서 데이터를 전달하는 통로로, CPU, 메모리, 입출력 장치 등 다양한 컴퓨터 구성 요소들이 데이터를 주고받을 수 있도록 한다. 버스는 데이터 버스, 주소 버스, 제어 버스로 나눌 수 있으며, 각각 데이터 전송, 메모리 주소 지정, 제어 신호 전달의 역할을 한다.

### 장치 드라이버란?

장치 드라이버(Device Driver)란 운영체제와 하드웨어 장치 사이의 통신을 담당하는 소프트웨어이다. 각 장치 컨트롤러는 해당 장치를 제어하기 위한 드라이버를 필요로 하며, 드라이버는 운영체제가 하드웨어 자원을 효율적으로 사용할 수 있도록 한다.

### 인터럽트

### 인터럽트란?

인터럽트(Interrupt)란 컴퓨터 시스템에서 CPU의 현재 작업을 중단시키고 즉각적으로 특정 작업을 수행하도록 하는 신호이다. 이는 외부 장치가 CPU에게 작업이 완료되었음을 알리거나, 긴급한 작업을 처리하기 위해 사용된다. 인터럽트는 하드웨어와 소프트웨어의 상호 작용 방식의 핵심 부분이다.

- 외부 장치에서 CPU에게 작업을 완료했다는 것을 알리기 위해도 사용되고 이외 다른 많은 목적으로 사용되며 하드웨어와의 상호 작용 방식의 핵심 부분이다.
- CPU가 인터럽트 되면, CPU는 하던 일을 중단하고 즉시 고정된 위치로 실행을 옮긴다.
- 이러한 고정된 위치는 일반적으로 인터럽트를 위한 서비스 루틴이 위치한 시작 주소를 가지고 있다. 그리고 인터럽트 서비스 루틴이 실행된다. 인터럽트 서비스 루틴이 실행이 완료되면 CPU는 인터럽트 되었던 연산을 재개한다.

### 인터럽트 서비스 루틴이란?

인터럽트 서비스 루틴(Interrupt Service Routine, ISR)이란 인터럽트 발생 시 실행되는 특수한 루틴으로, 인터럽트가 발생한 원인을 처리하고 필요한 작업을 수행한 후, 원래의 작업을 재개할 수 있도록 한다.

### 인터럽트 벡터란?

인터럽트 벡터(Interrupt Vector)란 각 인터럽트에 대해 고유한 서비스 루틴의 시작 주소를 저장한 테이블이다. CPU가 인터럽트를 처리할 때, 인터럽트 벡터를 통해 해당 인터럽트의 서비스 루틴의 주소를 찾는다.

### 인터럽트 요청 라인이란?

인터럽트 요청 라인(Interrupt Request Line, IRQ)이란 하드웨어 장치가 인터럽트를 요청하기 위해 사용하는 신호선이다. 각 하드웨어 장치는 특정 IRQ를 통해 CPU에 인터럽트를 요청할 수 있다.

### 인터렙트 핸들러 루틴이란?

인터럽트 핸들러 루틴(Interrupt Handler Routine)이란 인터럽트 발생 시 실행되는 코드로, 인터럽트 서비스 루틴과 유사한 개념이다. 핸들러는 인터럽트를 처리하고 필요한 조치를 취하는 역할을 한다.

### 인터럽트 컨트롤러 하드웨어란?

인터럽트 컨트롤러(Interrupt Controller)란 여러 장치로부터 들어오는 인터럽트를 관리하고 CPU에게 전달하는 하드웨어 장치이다. 이는 인터럽트 우선순위를 결정하고, 특정 인터럽트를 마스킹(비활성화)하거나 허용하는 역할을 한다.

### 마스크 불가능 인터럽트/마스크 가능 인터럽트

- 마스크 불가능 인터럽트(Non-Maskable Interrupt, NMI): CPU가 무조건 처리해야 하는 인터럽트로, 긴급하고 중요한 상황에서 사용된다. 사용자가 인터럽트를 비활성화할 수 없다.
- 마스크 가능 인터럽트(Maskable Interrupt): CPU가 처리 여부를 선택할 수 있는 인터럽트로, 운영체제가 필요에 따라 인터럽트를 마스킹하여 무시할 수 있다.

### 인터럽트 체인이란?

인터럽트 체인(Interrupt Chain)이란 동일한 인터럽트 벡터에 여러 인터럽트 서비스 루틴이 연결되어 있는 구조를 말한다. 인터럽트가 발생하면, 체인에 연결된 루틴들이 순차적으로 실행되어야 한다.

### 인터럽트 우선순위 레벨이란?

인터럽트 우선순위 레벨(Interrupt Priority Level)이란 여러 인터럽트가 동시에 발생할 때, 어떤 인터럽트를 먼저 처리할지 결정하는 기준이다. 우선순위 레벨이 높은 인터럽트가 먼저 처리되며, 낮은 우선순위의 인터럽트는 대기하게 된다.

이로써 컴퓨터 시스템의 구성과 인터럽트에 대한 주요 개념을 더 명확하게 이해할 수 있을 것입니다. 추가적인 설명이나 세부 사항이 필요하다면 언제든지 말씀해 주세요!

### 저장장치 구조

> 타이머란?

운영체제에서 타이머는 시스템의 시간을 추적하고 특정 이벤트를 정해진 시간 간격으로 발생시키기 위해 사용되는 중요한 컴포넌트입니다. 타이머는 주로 다음과 같은 용도로 사용됩니다:

1. **시간 관리**: 시스템 시간을 유지하고 관리합니다. 이는 프로세스와 스레드가 정확한 시간 동안 실행되도록 보장하는 데 중요합니다.
2. **시스템 틱 생성**: 운영체제는 주기적인 인터럽트를 생성하는 타이머를 사용하여 '틱'(tick)을 발생시킵니다. 이는 주기적인 작업을 수행하거나 시간 기반의 작업 스케줄링을 가능하게 합니다.
3. **프로세스 스케줄링**: 타이머 인터럽트는 운영체제가 프로세스 스케줄링 결정을 내리는 데 사용됩니다. 예를 들어, 프로세스가 할당된 CPU 시간을 초과하면 타이머 인터럽트가 발생하여 운영체제가 다른 프로세스로 전환할 수 있게 합니다.
4. **타임아웃 관리**: I/O 작업이나 네트워크 통신에서 특정 작업이 일정 시간 내에 완료되지 않으면 타임아웃이 발생하도록 설정할 수 있습니다. 이는 무한 대기를 방지하고 시스템 자원을 효율적으로 관리하는 데 중요합니다.

### 타이머의 작동 방식

1. **하드웨어 타이머**: 하드웨어 타이머는 시스템의 하드웨어에 내장된 타이머로, 특정 주기로 인터럽트를 발생시킵니다. 이는 운영체제가 시스템 틱을 생성하고 시간을 추적하는 데 사용됩니다.
2. **소프트웨어 타이머**: 소프트웨어 타이머는 운영체제나 애플리케이션 수준에서 구현됩니다. 하드웨어 타이머의 인터럽트를 기반으로 동작하며, 특정 이벤트를 예약하고 관리합니다.

### 타이머 인터럽트

타이머 인터럽트는 주기적으로 발생하여 운영체제에 특정 작업을 수행할 수 있는 기회를 제공합니다. 예를 들어:

- **프로세스 스케줄링**: 현재 실행 중인 프로세스의 시간을 확인하고, 만약 할당된 시간을 초과하면 다른 프로세스로 전환합니다.
- **시스템 시간 업데이트**: 시스템 시간을 주기적으로 업데이트하여 시간 기반의 이벤트를 정확하게 처리할 수 있도록 합니다.
- **주기적인 작업 수행**: 운영체제나 애플리케이션에서 주기적으로 수행해야 하는 작업을 실행합니다. 예를 들어, 메모리 정리 작업이나 로그 기록 등이 있습니다.

### 구현 예시

타이머는 주로 다음과 같은 API를 통해 사용됩니다:

- **POSIX 타이머**: POSIX 표준에 정의된 타이머로, `timer_create`, `timer_settime`, `timer_gettime` 등의 함수를 사용하여 타이머를 생성하고 관리합니다.
- **윈도우 타이머**: 윈도우 운영체제에서는 `SetTimer`, `KillTimer`, `Waitable Timer` 등의 API를 통해 타이머를 설정하고 사용할 수 있습니다.

### 주요 개념

- **틱 (Tick)**: 타이머가 주기적으로 발생시키는 인터럽트의 단위 시간. 일반적으로 1 밀리초나 10 밀리초 단위로 설정됩니다.
- **타임 슬라이스 (Time Slice)**: 프로세스가 CPU를 점유할 수 있는 최대 시간. 이 시간이 지나면 스케줄러에 의해 다른 프로세스로 전환됩니다.
- **타임아웃 (Timeout)**: 특정 작업이 완료되지 않았을 때 시스템이 해당 작업을 중단하고 다른 작업을 수행하도록 하는 시간 제한.

타이머는 운영체제가 시간과 이벤트를 효율적으로 관리하고 시스템 자원을 최적화하는 데 필수적인 역할을 합니다.

> 프로그램 카운터란?

프로그램 카운터(Program Counter, PC)는 CPU 내부의 중요한 레지스터 중 하나로, 현재 실행 중인 명령어의 주소를 저장하는 역할을 합니다. 프로그램 카운터는 명령어의 흐름을 제어하고 프로그램의 순차적인 실행을 가능하게 하는 핵심적인 컴포넌트입니다.

### 프로그램 카운터의 기능

1. **명령어 주소 저장**: 프로그램 카운터는 현재 실행 중인 명령어의 주소를 저장합니다. CPU가 명령어를 실행할 때마다 프로그램 카운터는 해당 명령어의 메모리 주소를 가리킵니다.
2. **명령어 순차 실행**: CPU가 명령어를 실행한 후, 프로그램 카운터는 자동으로 다음 명령어의 주소로 증가합니다. 일반적으로 명령어의 크기(예: 1바이트, 4바이트 등)에 따라 증가합니다. 이로 인해 프로그램은 순차적으로 명령어를 실행할 수 있습니다.
3. **분기와 점프 처리**: 조건부 또는 무조건부 분기 명령어가 실행되면, 프로그램 카운터는 다음 실행할 명령어의 주소를 해당 분기 주소로 설정합니다. 이는 프로그램 흐름의 제어를 가능하게 하며, 반복문, 조건문 등의 구현을 지원합니다.
4. **인터럽트 처리**: 인터럽트가 발생하면, 현재 명령어의 주소는 저장되고, 프로그램 카운터는 인터럽트 서비스 루틴(ISR)의 시작 주소로 설정됩니다. 인터럽트 처리가 완료되면, 프로그램 카운터는 원래의 실행 위치로 복원됩니다.

### 프로그램 카운터의 동작 과정

1. **명령어 가져오기(Fetch)**: 프로그램 카운터가 가리키는 메모리 주소에서 명령어를 가져옵니다.
2. **명령어 실행(Execute)**: 가져온 명령어를 디코드하고 실행합니다.
3. **프로그램 카운터 증가(Update PC)**: 다음 명령어의 주소로 프로그램 카운터를 증가시킵니다.

이 과정은 반복적으로 수행되어 프로그램이 순차적으로 실행됩니다.

### 예시

다음은 간단한 프로그램의 실행 예시입니다:

assembly

코드 복사

`0x0000: LOAD R1, 0x1000   ; R1에 메모리 주소 0x1000의 값을 로드 0x0004: ADD R1, R2        ; R1에 R2의 값을 더함 0x0008: STORE R1, 0x1004  ; R1의 값을 메모리 주소 0x1004에 저장 0x000C: JMP 0x0000        ; 0x0000 주소로 점프`

- **시작 시**: 프로그램 카운터(PC)는 0x0000을 가리킵니다.
- **LOAD 명령어 실행 후**: PC는 0x0004로 증가합니다.
- **ADD 명령어 실행 후**: PC는 0x0008로 증가합니다.
- **STORE 명령어 실행 후**: PC는 0x000C로 증가합니다.
- **JMP 명령어 실행 후**: PC는 0x0000으로 설정되어 프로그램의 처음으로 되돌아갑니다.

### 프로그램 카운터의 중요성

- **프로그램 흐름 제어**: 프로그램 카운터는 명령어의 순차적인 실행을 가능하게 하며, 조건부 분기, 반복문, 함수 호출 등의 제어 구조를 지원합니다.
- **디버깅**: 프로그램 카운터의 값은 디버깅 과정에서 현재 실행 중인 명령어를 확인하는 데 사용됩니다. 이를 통해 오류를 추적하고 수정할 수 있습니다.
- **효율적인 CPU 동작**: 프로그램 카운터는 명령어의 주소를 효율적으로 관리하여 CPU가 고속으로 명령어를 처리할 수 있도록 합니다.

프로그램 카운터는 CPU의 필수적인 레지스터로서, 프로그램의 올바른 실행과 흐름 제어를 담당합니다. 이를 통해 복잡한 프로그램의 실행이 가능해지고, 다양한 제어 구조를 구현할 수 있습니다.

> 캐시 일관성을 위한 MESI 프로토콜의 동작

MESI 프로토콜은 멀티프로세서 시스템에서 캐시 일관성을 유지하기 위한 대표적인 방법입니다. 이 프로토콜은 각 캐시 라인이 Modified, Exclusive, Shared, Invalid의 네 가지 상태 중 하나로 마킹되며, 상태 전이를 통해 캐시 일관성을 유지합니다. 각 상태와 상태 전이가 언제, 어떻게 발생하는지, 그리고 다른 코어들이 이를 어떻게 인지하는지에 대해 자세히 설명하겠습니다.

### MESI 상태 설명

1. **Modified (M)**

   - 캐시 라인은 현재 캐시에서 수정되었으며, 메모리에는 반영되지 않은 상태입니다.
   - 이 데이터는 해당 캐시에서만 유효합니다.

2. **Exclusive (E)**

   - 캐시 라인은 수정되지 않았으며, 현재 캐시에서만 유효한 상태입니다.
   - 메모리와 동일한 값을 가지며, 다른 캐시에는 존재하지 않습니다.

3. **Shared (S)**

   - 캐시 라인은 수정되지 않았으며, 여러 캐시에서 공유될 수 있는 상태입니다.
   - 메모리와 동일한 값을 가지며, 다른 캐시에서도 존재할 수 있습니다.

4. **Invalid (I)**

   - 캐시 라인은 유효하지 않은 상태입니다.
   - 이 상태에서는 캐시 라인의 데이터가 더 이상 사용되지 않습니다.

### 상태 전이와 마킹

캐시 라인의 상태는 다음과 같은 이벤트에 의해 전이됩니다:

1. **CPU Read (읽기 요청)**

   - **Invalid (I) → Shared (S)**
     - 다른 캐시에서 해당 라인이 공유 상태로 존재하면, I 상태에서 S 상태로 전이됩니다.
   - **Invalid (I) → Exclusive (E)**
     - 다른 캐시에서 해당 라인이 존재하지 않으면, I 상태에서 E 상태로 전이됩니다.
   - **Shared (S) → Shared (S)**
     - 이미 S 상태이면 그대로 유지됩니다.
   - **Exclusive (E) → Exclusive (E)**
     - 이미 E 상태이면 그대로 유지됩니다.
   - **Modified (M) → Modified (M)**
     - 이미 M 상태이면 그대로 유지됩니다.

2. **CPU Write (쓰기 요청)**

   - **Invalid (I) → Modified (M)**
     - 다른 캐시에서 해당 라인이 공유 상태로 존재하지 않으면, I 상태에서 M 상태로 전이됩니다.
   - **Shared (S) → Modified (M)**
     - 다른 캐시에서 해당 라인이 공유 상태로 존재하면, S 상태에서 M 상태로 전이되며, 다른 캐시의 해당 라인은 Invalid 상태로 변경됩니다.
   - **Exclusive (E) → Modified (M)**
     - E 상태에서 M 상태로 전이됩니다.

3. **Bus Read (버스 읽기 요청)**

   - **Modified (M) → Shared (S)**
     - 다른 캐시가 읽기 요청을 하면, M 상태에서 S 상태로 전이됩니다.
   - **Exclusive (E) → Shared (S)**
     - 다른 캐시가 읽기 요청을 하면, E 상태에서 S 상태로 전이됩니다.

4. **Bus Write (버스 쓰기 요청)**

   - **Shared (S) → Invalid (I)**
     - 다른 캐시가 쓰기 요청을 하면, S 상태에서 I 상태로 전이됩니다.
   - **Exclusive (E) → Invalid (I)**
     - 다른 캐시가 쓰기 요청을 하면, E 상태에서 I 상태로 전이됩니다.
   - **Modified (M) → Invalid (I)**
     - 다른 캐시가 쓰기 요청을 하면, M 상태에서 I 상태로 전이됩니다.

### 다른 코어에서 어떻게 아는가?

MESI 프로토콜은 캐시 일관성을 유지하기 위해 **버스 스누핑 (Bus Snooping)** 메커니즘을 사용합니다. 이는 모든 캐시가 시스템 버스를 모니터링하여 다른 캐시의 상태 변경을 감지하는 방식입니다. 다음은 버스 스누핑이 어떻게 작동하는지에 대한 설명입니다:

1. **버스 트랜잭션 모니터링**

   - 모든 캐시는 시스템 버스를 모니터링하여 다른 코어가 수행하는 메모리 읽기 또는 쓰기 요청을 감지합니다.

2. **상태 변경**

   - 한 캐시가 버스를 통해 메모리 읽기 또는 쓰기 요청을 하면, 다른 캐시는 이를 감지하고 해당 캐시 라인의 상태를 적절히 변경합니다.
   - 예를 들어, 한 코어가 특정 메모리 주소에 대한 쓰기 요청을 하면, 그 메모리 주소를 가진 다른 캐시는 해당 라인을 Invalid 상태로 변경합니다.

3. **데이터 공유**

   - 한 캐시가 버스에서 읽기 요청을 할 때, Modified 상태의 데이터를 가진 다른 캐시는 그 데이터를 공유합니다. 이는 데이터를 메모리로 쓰기 전에 다른 캐시로 직접 전달하여 효율성을 높입니다.

### 예시 시나리오

1. **초기 상태**

   - CPU1과 CPU2가 각각의 L1 캐시에 동일한 메모리 주소 X를 Invalid 상태로 가지고 있습니다.

2. **CPU1이 메모리 주소 X를 읽음**

   - CPU1의 캐시 라인은 Invalid (I)에서 Exclusive (E)로 전이됩니다.
   - 다른 캐시는 이 메모리 주소에 대해 아무런 작업을 하지 않습니다.

3. **CPU2가 메모리 주소 X를 읽음**

   - CPU2의 캐시 라인은 Invalid (I)에서 Shared (S)로 전이됩니다.
   - CPU1의 캐시 라인도 Exclusive (E)에서 Shared (S)로 전이됩니다.

4. **CPU2가 메모리 주소 X에 씀**

   - CPU2의 캐시 라인은 Shared (S)에서 Modified (M)로 전이됩니다.
   - CPU1의 캐시 라인은 Shared (S)에서 Invalid (I)로 전이됩니다.
   - 버스 트랜잭션을 통해 CPU2의 쓰기 요청이 감지되어 CPU1이 해당 캐시 라인을 Invalid 상태로 변경합니다.

### 결론

MESI 프로토콜은 버스 스누핑을 통해 각 캐시가 메모리 접근 트랜잭션을 모니터링하고, 캐시 라인의 상태를 적절히 전이시켜 일관성을 유지합니다. 이 방식은 멀티코어 시스템에서 데이터의 일관성을 보장하며, 시스템 전체의 효율성을 높입니다.
